grammar sdu.mdsd.IoT with org.eclipse.xtext.common.Terminals

import "http://www.eclipse.org/emf/2002/Ecore" as ecore
generate ioT "http://www.mdsd.sdu/IoT"

Model:
	deviceTypes+=DeviceDefinition*
	system=IoTSystem;

DeviceDefinition:
	'devicetype' name=ID fileName=STRING ':'
	body=STRING
	templates+=Template*;

Template:
	WlanTmpl | SocketListenTmpl | SensorTmpl | SocketConnectTmpl | LoopTmpl | ArrowTmpl | ListDeclTmpl | ListAddTmpl |
	ListClearTmpl | ExternalTmpl | ToVarTmpl | LEDTmpl | IfStatementTmpl | SerialReadTmpl | SerialWriteTmpl |
	ReadVariableTmpl | TrueTmpl |
	FalseTmpl |
	IntTmpl | VariableTmpl | VariableWithInstantiationTmpl | OrTmpl | AndTmpl | EqlTmpl | GreaterThanTmpl | LessThanTmpl
	| LessThanEqualTmpl | GreatThanEqualTmpl | EqualOpTmpl | NotEqualTmpl |
	ItemVariableTmpl | ItemIntTmpl | ItemBoolTmpl;

SerialWriteTmpl:
	"serialwrite" params=TmplParams? ':'
	body=TmplBody;

VariableWithInstantiationTmpl:
	"variableInstantiation" params=TmplParams? ':'
	body=TmplBody;

ItemBoolTmpl:
	'ibool' params=TmplParams? ':'
	body=TmplBody;

ItemIntTmpl:
	'iint' params=TmplParams? ':'
	body=TmplBody;

ItemVariableTmpl:
	'ivar' params=TmplParams? ':'
	body=TmplBody;

NotEqualTmpl:
	'neqlop' params=TmplParams? ':'
	body=TmplBody;

EqualOpTmpl:
	'eqlop' params=TmplParams? ':'
	body=TmplBody;

GreatThanEqualTmpl:
	'gteop' params=TmplParams? ':'
	body=TmplBody;

LessThanEqualTmpl:
	'lteop' params=TmplParams? ':'
	body=TmplBody;

LessThanTmpl:
	'ltop' params=TmplParams? ':'
	body=TmplBody;

GreaterThanTmpl:
	'gtop' params=TmplParams? ':'
	body=TmplBody;

EqlTmpl:
	'eql' params=TmplParams? ':'
	body=TmplBody;

AndTmpl:
	'andop' params=TmplParams? ':'
	body=TmplBody;

OrTmpl:
	'orop' params=TmplParams? ':'
	body=TmplBody;

FalseTmpl:
	'falseLiteral' params=TmplParams? ':'
	body=TmplBody;

TrueTmpl:
	'trueLiteral' params=TmplParams? ':'
	body=TmplBody;

VariableTmpl:
	'vardecl' params=TmplParams? ':'
	body=TmplBody;

IntTmpl:
	'int' params=TmplParams? ':'
	body=TmplBody;

ReadVariableTmpl:
	'varread' params=TmplParams? ':'
	body=TmplBody;

SerialReadTmpl:
	'serialread' params=TmplParams? ':'
	body=TmplBody;

IfStatementTmpl:
	'if' params=TmplParams? ':'
	body=TmplBody;

LEDTmpl:
	'led' params=TmplParams? ':'
	body=TmplBody;

ToVarTmpl:
	'varassign' params=TmplParams? ':'
	body=TmplBody;

SocketConnectTmpl:
	'socketconnection' params=TmplParams? ':'
	body=TmplBody;

SensorTmpl:
	'sensor' name=ID params=TmplParams? ':'
	body=TmplBody;

TmplBody:
	{TmplBody}
	('import:' imports=STRING)?
	('setup:' setup=STRING)?
	('use:' use=STRING)?;

TmplParams:
	'(' params+=TmplParam (',' params+=TmplParam)* ')';

TmplParam:
	meaning=ID '=' name=ID;

ExternalTmpl:
	'external' params=TmplParams? ':'
	body=TmplBody;

ListDeclTmpl:
	'listdeclare' params=TmplParams? ':'
	body=TmplBody;

ListClearTmpl:
	'listclear' params=TmplParams? ':'
	body=TmplBody;

ListAddTmpl:
	'listaddto' params=TmplParams? ':'
	body=TmplBody;

ArrowTmpl:
	'arrow' params=TmplParams? ':'
	body=TmplBody;

LoopTmpl:
	'loop' params=TmplParams? ':'
	body=TmplBody;

SocketListenTmpl:
	'socketlisten' params=TmplParams? ':'
	body=TmplBody;

WlanTmpl:
	'wlan' params=TmplParams? ':'
	body=TmplBody;

IoTSystem:
	{IoTSystem}
	externalDeclarations+=ExternalDeclaration*
	configs+=ConnectionConfig*
	devices+=Device*;

terminal IP returns ecore::EString:
	INT '.' INT '.' INT '.' INT; // IP
terminal WINDOWS_SERIAL returns ecore::EString:
	'COM' INT;

ExternalDeclaration:
	'external' name=ID // '(' type=STRING ')' // Commented out due to not being used
;

/*
 * Configurations
 */
ConnectionConfig returns Config:
	{ConnectionConfig} 'connectionConfig' name=ID '{'
	'type' ':' type=ConfigType
	declarations+=Declaration*
	'}';

ConfigType:
	'SERIAL' | 'WLAN';

Declaration:
	key=STRING ':' value=STRING;

	/*
 * Device 
 */
Device:
	deviceType=[DeviceDefinition] 'device' name=ID '{'
	program=Program
	'}';

Program:
	{Program} topLevelCommands+=TopLevelCommand*;

TopLevelCommand:
	WifiStatement | ConnectStatement | VarOrList | ListenStatement | Loop;

ListenStatement:
	'listen' 'on' ip=IP ':' port=INT '->' body=ExpressionRight;

WifiStatement:
	'setup' connectionConfig=[ConnectionConfig];

ConnectStatement:
	'connect' 'to' device=[Device] 'on' address=Address 'using' configuration=[ConnectionConfig];

Address:
	{IpAddress} value=IP |
	{SerialAddress} value=STRING // TODO: validation
;

VarOrList:
	({Variable} 'var' name=ID ('=' value=Expression)? | {IdkList} 'list' name=ID);

Loop:
	{Loop}
	('always' | 'every' timeVal=Expression timeUnit=TIMEUNIT) '{'
	command+=Command*
	'}';

TIMEUNIT:
	{MILLISECONDS} 'MILLISECONDS' |
	{SECONDS} 'SECONDS' |
	{MINUTES} 'MINUTES' |
	{HOURS} 'HOURS' |
	{DAYS} 'DAYS' |
	{WEEKS} 'WEEKS';

Command:
	Action | ArrowCommand | IfStatement;

Action returns Command:
	ClearListAction |
	LEDAction;

ClearListAction returns Action:
	{ClearListAction} 'clear' list=[IdkList];

LEDAction returns Action:
	{LEDAction} 'LED' state=('ON' | 'OFF');

ArrowCommand returns Command:
	{ArrowCommand} left=ExpressionLeft '->' right=ExpressionRight;

ExpressionLeft returns Command:
	ExternalOf | ReadSensor | ReadConnection | ReadVariable | Expression;

Expression:
	BoolExpression | IntExpression | {VarAccess} variableName=[VarOrList];

BoolExpression:
	value=Bool;

IntExpression:
	value=INT;

ReadVariable:
	'read' 'var' value=[Variable];

ReadConnection:
	'read' 'from' source=[Device];

ExternalOf:
	method=[ExternalDeclaration] 'of' target=[VarOrList];

ReadSensor:
	'read' 'sensor' sensor=[SensorTmpl];

ExpressionRight returns Command:
	SendCommand | AddToList | ToVar | ExternalRight | Block;

Block:
	'{' commands+=Command+ '}';

ToVar returns ExpressionRight:
	{ToVar} 'to' variable=[Variable];

AddToList returns ExpressionRight:
	{AddToList} 'add' 'to' list=[IdkList];

ExternalRight:
	method=[ExternalDeclaration] 'of' 'value';

SendCommand returns ExpressionRight:
	{SendCommand} 'send' 'to' target=[Device];

IfStatement returns Command:
	{IfStatement} 'if' condition=Comparison '{' commands+=Command+ '}' (elseBlock=ElseBlock)?;

ElseBlock:
	{ElseBlock} 'else' '{' commands+=Command+ '}';

Comparison returns Comparison:
	OR;

OR returns Comparison:
	AND ({OR.left=current} ('||' | 'OR') right=AND)*;

AND returns Comparison:
	EQL ({AND.left=current} ('&&' | 'AND') right=EQL)*;

EQL returns Comparison:
	Item ({EQL.left=current} op=ComparisonOp right=Item)?;

Item returns Comparison:
	Parenthasis |
	{ItemVariable} value=[Variable] |
	{ItemInt} value=INT |
	{ItemBool} value=BoolExpression;

Parenthasis returns Comparison:
	'(' Comparison ')';

ComparisonOp:
	{GT} op='>' |
	{LT} op='<' |
	{LE} op='<=' |
	{GE} op='>=' |
	{EQ} op='==' |
	{NE} op='!=';

Bool:
	{True} ('TRUE' | 'true') | {False} ('FALSE' | 'false');

