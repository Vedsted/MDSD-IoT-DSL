/*
 * generated by Xtext 2.20.0
 */
package sdu.mdsd.generator

import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.UUID
import java.util.stream.Collectors
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import sdu.mdsd.ioT.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class IoTGenerator extends AbstractGenerator {
	Device currentDevice;
	List<String> usedSetups;
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		// var model = resource.allContents.filter(Model).toList
		for (dev : resource.allContents.filter(Device).toList) {
			fsa.generateFile('''«dev.name»/«dev.deviceType.fileName»''', dev.convertDevice)
		}
	}
	def convertDevice(Device device) {
		currentDevice = device
		usedSetups = new ArrayList<String>()
		var importString = buildImports(device)
		var programString = buildProgram(device)

		var string =  device.deviceType.body;
		string = string.cleverReplace("{{IMPORTS}}", importString)
		string = string.cleverReplace("{{SETUP}}", buildSetups())
		string = string.cleverReplace("{{PROGRAM}}", programString)
		return string
	}
	def buildImports(Device device) {
		// TODO ideally only import things used in the program, but you know
		var imports = device.deviceType.implementations.filter[body.imports !== null].map[body.imports].toList
		var strings = new ArrayList<String>();
		for (import : imports) {
			// Split on new line to get each import as a separate line.
			// So we can check for duplicates
			strings.addAll(import.split("\n"))
		}
		// Return distinct list to string
		return strings.stream.distinct.collect(Collectors.toList()).join("\n")
	}
	def buildSetups() {
		var sb = new StringBuilder();
		for (setup : usedSetups.stream.distinct().collect(Collectors.toList)) {
			sb.append(setup);
			sb.append("\n")
		}
		return sb.toString()
	}
	def buildProgram(Device device) {
		var sb = new StringBuilder()
		var program = device.program
		for (cmd : program.topLevelCommands) {
			sb.append(cmd.generateCode)
			sb.append("\n")
		}
		return sb.toString()
	}

	var loopCount = 0;

	def String generateCode(TopLevelCommand command) {
		var params = new HashMap<String, String>()
		var Class<? extends Implementation> klass;
		switch (command) {
			WifiStatement: {
				var ssid = command.connectionConfig?.declarations?.extractDeclaration("ssid")?.value;
				var pw = command.connectionConfig?.declarations?.extractDeclaration("password")?.value;
				if (ssid === null || pw === null)
					throw new Exception("You should have a connectConfig before connecting to wifi")
				params.put("SSID", ssid)
				params.put("PASSWORD", pw)
				klass = WlanImpl
			}
			ListenStatement: {
				
				params.put("IP", command.ip)
				params.put("PORT", command.port.toString())
				params.put("COMMANDS", command.body.buildCommand)
			klass = SocketListenImpl
			}
			VarOrList: {
				switch (command) {
					Variable: {
						throw new Exception("NOT IMPLEMENTED YET")
					}
					PyList: {
						params.put("NAME", command.name);
						klass = ListDeclImpl
					}
					default:
						throw new Exception("NOT A VAR OR LIST")
				}
			}
			Loop: {
				params.put("TSECONDS", command.convertSleepTime)
				params.put("NAME", loopCount.toString())
				loopCount++;
				params.put("COMMANDS", command.command.buildCommands())
				klass = LoopImpl
			}
			ConnectStatement: {
				throw new Exception("NOT IMPLEMENTED YET")
			}
		}
		doSetup(klass,params)
		return getUseCodeFor(klass, params)
	}

	def String buildCommands(EList<Command> list) {
		var sb = new StringBuilder();
		for (cmd : list) {
			sb.append(cmd.buildCommand())
			sb.append("\n")
		}
		return sb.toString()
	}

	def String buildCommand(Command command) {
		var params = new HashMap<String, String>()
		var Class<? extends Implementation> klass;
		switch (command) {
			ArrowCommand: {
				params.put("LEFT", command.left.buildCommand)
				params.put("RIGHT", command.right.buildCommand)
				val uuid = UUID.randomUUID.toString.replace('-', '_'); // dashes are illegal in method names in python
				params.put("UUID", uuid)
				klass = ArrowImpl
			}
			ClearListAction: {
				params.put("NAME", command.list.name)
				klass = ListClearImpl
			}
			ReadSensor: {
				doSetup(SensorImpl, params)
				klass = SensorImpl
			}
			ExternalOf: {
				params.put("NAME", command.method.name)
				params.put("TARGETNAME", command.target.name)
				klass = ExternalImpl
			}
			AddToList: {
				params.put("NAME", command.list.name)
				klass = ListAddImpl
			}
			SendCommand: {
				params.put("IP", command.target.program.topLevelCommands.filter(ListenStatement).get(0).ip)
				params.put("PORT",
					command.target.program.topLevelCommands.filter(ListenStatement).get(0).port.toString())
				params.put("TARGET_DEVICE", command.target.name)
				klass = SocketConnectImpl
			}
			ExternalRight: {
				params.put("NAME", command.method.name)
				klass = ExternalImpl
			}
		}
				doSetup(klass,params)
		return getUseCodeFor(klass, params)
	}

	def doSetup(Class<? extends Implementation> class1, Map<String, String> paramsMap) {

		var implementations = currentDevice.deviceType.implementations.filter(class1).toList

		for (impl : implementations) {
			var setup = impl.body.setup;
			if (setup !== null) {

				var setUpCode = setup.insertParameters(impl.params?.params, paramsMap)
				usedSetups.add(setUpCode);
			}
		}

	}

	def getUseCodeFor(Class<? extends Implementation> class1, Map<String, String> paramsMap) {
		var sb = new StringBuilder();
		var implementations = currentDevice.deviceType.implementations.filter(class1).toList

		for (impl : implementations) {
			var use = impl.body.use;
			if (use !== null) {

				var useCode = use.insertParameters(impl.params?.params, paramsMap)
				sb.append(useCode)
			}
		}
		return sb.toString()

	}

	def insertParameters(String setup, List<ImplParam> params, Map<String, String> paramsMap) {
		var codeString = setup
		if (codeString === null) {
			throw new Exception("Why is the code string null")
		}
		if (params === null)
			return codeString
		//var paramList = params.replace('(', '').replace(')', '').split(',').map[trim()];
		for (paramObj : params) {
			var param = paramObj.name
			var newValue = paramsMap.get(paramObj.meaning);
			if (newValue === null) {
				throw new Exception('''«param» was null''')
			}
			codeString = codeString.cleverReplace('''{{«param»}}''', newValue)
		}
		return codeString;
	}

	/**
	 * replaces one string with another string and attempts to make nice indentation
	 */
	def cleverReplace(String codeString, String param, String newValue) {
		var codeStringLines = codeString.split("\n")
		var newLines = newValue.split("\n")
		for (var i = 0; i < codeStringLines.length; i++) {
			var line = codeStringLines.get(i);
			if (line.contains(param)) {
				var indentChars = line.toCharArray().takeWhile[c|c == ' ' || c == '\t']
				var resultsb = new StringBuilder()
				for (nline : newLines) {
					resultsb.append(new String(indentChars));
					resultsb.append(line.replace(param, nline))
					resultsb.append('\n')
				}

				codeStringLines.set(i, resultsb.toString())
			}
		}
		return codeStringLines.join('\n')
	}

	def extractDeclaration(List<Declaration> declarations, String _key) {
		val d = declarations.filter[key == _key]
		d.length > 0 ? d.get(0) : null
	}

	def String convertSleepTime(Loop loop) {
		if (loop.timeVal === null) {
			return "0"
		}
		val exp = loop.timeVal

		switch (exp) {
			VarAccess: {
				return exp.variableName.name
			}
			IntExpression: {
				return convertTime(loop.timeUnit, exp.value).toString
			}
			default:
				throw new Exception("Invalid time value" + exp)
		}
	}

	def convertTime(TIMEUNIT timeunit, int timevalue) {
		switch timeunit {
			MILLISECONDS: timevalue / 1000.0
			SECONDS: timevalue
			MINUTES: timevalue * 60
			HOURS: timevalue * 3600
			DAYS: timevalue * 24 * 3600
			WEEKS: timevalue * 7 * 24 * 3600
		}
	}
}
